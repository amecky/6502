# 6502
This is yet another 6502 emulator. I got bored and came up with this. This project
is the effort of a few weekends spent on building a simple emulator.
It is a single header only implementation. My first try at writing such a thing.
All you need to include in your code is the 6502.h. More details are described below.
The current version is kind of a beta version. I am sure it still contains bugs
and there are parts I would like to improve on. But it is working.

# What you get

There are actually three more sub projects included. The basic of course the emulator itself.
The UnitTests is a subproject for running unit tests on the actual implementation. Next is
shell which is a simple command shell using the emulator. Also there is a windows MFC application
as frontend for the 6502.h. 

# Usage
Copy the 6502.h into your source code directory or where ever you would like.
In one of your c/cpp files you need to define VM_IMPLEMENTATION before you include 6502.h. This will 
generate the actual implementation. Otherwise only the header is included.

```c
#define VM_IMPLEMENTATION
#include "6502.h"

```

# API

```c
vm_context* vm_create();
```
Creates the internal vm_context. You need to call it once to initialize the virtual machine.

```c
void vm_release();
```
Destroys the internal vm_context. Make sure to call it at the end of your program.

```c
bool vm_load(const char* fileName);
```
Loads a binary file into memory at location 0x600.

```c	
bool vm_save(const char* fileName);
```
Saves the binary data to a file.

```c
int vm_assemble_file(const char* fileName);
```
Loads a text file containing some code and run the assembler. The generated byte code is located at 0x600 in memory.

```c
void vm_disassemble(std::string& out);
```
This method will disassemble the binary data at location 0x600 and put it into the string.

```c
int vm_assemble(const char* code);
```
This method will assemble the given code to memory starting at 0x600

```c
void vm_dump(int pc, int num);
```

```c
void vm_dump_registers();
```

```c
void vm_memory_dump(int pc, int num);
```


```c
void vm_run();
```
Will run the byte code at location 0x600. Make sure that you have either loaded or assembled your code before running it.

```c
bool vm_step();
```

```c
void vm_reset();
```
Resets the registers and flags and also the program counter will be set to 0x600.

# Examples

The following code will assemble and run some very simple ASM code. 
```c
// create context
vm_context* ctx = vm_create();
// assemble short piece of ASM
vm_assemble("LDA #$20\nSTA $0200\n");
// run it
vm_run();
// print accumulator
printf("A: %02X\n", ctx->registers[vm_registers::A]);
// and the value stored in memory
printf("Memory: %02X\n", ctx->read(0x200));
// dump registers
vm_dump_registers();
// and also the memory
vm_dump_memory(0x200, 16);
// we are done.	
vm_release();
```
    
This will result in the following output:
```c
A: 20
Memory: 20
------------- Dump -------------
A=$20 X=$00 Y=$00
PC=$0605 SP=$FF
CZIDBVN
0000000
---------- Memory dump -----------
0200 : 20 00 00 00 00 00 00 00
0208 : 00 00 00 00 00 00 00 00
```
    
# Status

This project is an beta version. I would consider the API to be pretty stable. But there might
be some changes coming up internally. Also I am pretty sure the code contains bugs since not
everything is covered by unit tests yet.

# Changelist

No intial release so far

# License

The project is released under the MIT license

# Contact and contributions
You can always send me an email to amecky@gmail.com. Also if you like to contribute or send me a bug fix
you are always welcome.